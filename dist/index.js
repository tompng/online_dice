/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst canvas = document.createElement('canvas');\nconst SIZE = 512;\ncanvas.width = canvas.height = SIZE;\ndocument.body.appendChild(canvas);\nclass Vector3 {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    clone() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n    scale(a) {\n        return new Vector3(a * this.x, a * this.y, a * this.z);\n    }\n    length() {\n        return Math.hypot(this.x, this.y, this.z);\n    }\n    normalize() {\n        const r = this.length();\n        return new Vector3(this.x / r, this.y / r, this.z / r);\n    }\n    static dot(va, vb) {\n        return va.x * vb.x + va.y * vb.y + va.z * vb.z;\n    }\n    static cross(va, vb) {\n        return new Vector3(va.y * vb.z - va.z * vb.y, va.z * vb.x - va.x * vb.z, va.x * vb.y - va.y * vb.x);\n    }\n    static distance(va, vb) {\n        return Math.hypot(va.x - vb.x, va.y - vb.y, va.z - vb.z);\n    }\n    static wsum(a, va, b, vb) {\n        return new Vector3(a * va.x + b * vb.x, a * va.y + b * vb.y, a * va.z + b * vb.z);\n    }\n    static add(va, vb) {\n        return this.wsum(1, va, 1, vb);\n    }\n    static sub(va, vb) {\n        return this.wsum(1, va, -1, vb);\n    }\n}\nfunction vectorMinus(v, n) {\n    const l = v.length();\n    if (l <= n)\n        return new Vector3(0, 0, 0);\n    return v.scale((l - n) / l);\n}\nclass Matrix3 {\n    constructor(data) {\n        this.elements = data !== null && data !== void 0 ? data : [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n    clone() {\n        return new Matrix3([...this.elements]);\n    }\n    transform(v) {\n        const e = this.elements;\n        return new Vector3(v.x * e[0] + v.y * e[1] + v.z * e[2], v.x * e[3] + v.y * e[4] + v.z * e[5], v.x * e[6] + v.y * e[7] + v.z * e[8]);\n    }\n    mult(m) {\n        const out = new Matrix3();\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                let sum = 0;\n                for (let k = 0; k < 3; k++) {\n                    sum += this.elements[3 * i + k] * m.elements[3 * k + j];\n                }\n                out.elements[3 * i + j] = sum;\n            }\n        }\n        return out;\n    }\n    add(m) {\n        const out = new Matrix3();\n        for (let i = 0; i < 9; i++) {\n            out.elements[i] = this.elements[i] + m.elements[i];\n        }\n        return out;\n    }\n    static fromRotation(axis, theta) {\n        const r = Math.hypot(axis.x, axis.y, axis.z);\n        const th = theta !== null && theta !== void 0 ? theta : r;\n        if (th === 0)\n            return new Matrix3();\n        const cos = Math.cos(th);\n        const sin = Math.sin(th);\n        const nx = axis.x / r;\n        const ny = axis.y / r;\n        const nz = axis.z / r;\n        const cc = 1 - cos;\n        const xy = nx * ny * cc;\n        const yz = ny * nz * cc;\n        const zx = nz * nx * cc;\n        return new Matrix3([\n            nx * nx * cc + cos, xy - nz * sin, zx + ny * sin,\n            xy + nz * sin, ny * ny * cc + cos, yz - nx * sin,\n            zx - ny * sin, yz + nx * sin, nz * nz * cc + cos\n        ]);\n    }\n}\nfunction randomDirection(l = 1) {\n    const z = 2 * Math.random() - 1;\n    const r = Math.sqrt(1 - z * z);\n    const th = 2 * Math.PI * Math.random();\n    return new Vector3(l * r * Math.cos(th), l * r * Math.sin(th), l * z);\n}\nconst Gravity = new Vector3(0, 0, -1);\nclass Cube {\n    constructor(position) {\n        this.size = 1;\n        this.position = position;\n        this.rotation = Matrix3.fromRotation(randomDirection(), 2 * Math.PI * Math.random());\n        this.rotation = new Matrix3(); //Matrix3.fromRotation(randomDirection(), 2 * Math.PI * Math.random())\n        // this.velocity = randomDirection()\n        this.momentum = randomDirection(4);\n        this.velocity = new Vector3(0, 0, 0);\n        // this.momentum = new Vector3(0, 0.8, 0)\n    }\n    update(dt) {\n        this.velocity = Vector3.add(this.velocity, Gravity.scale(dt));\n        this.position = Vector3.add(this.position, this.velocity.scale(dt));\n        const w = Matrix3.fromRotation(this.momentum, this.momentum.length() * dt);\n        this.rotation = w.mult(this.rotation);\n        this.hitFloor();\n    }\n    hitFloor() {\n        const floorZ = -4;\n        const faceDown = Cube.faces.some(n => this.rotation.transform(n).z > 0.999);\n        Cube.coords.forEach(coord => {\n            const rpos = this.rotation.transform(coord).scale(this.size);\n            const point = Vector3.add(this.position, rpos);\n            if (point.z > floorZ)\n                return;\n            const h = floorZ - point.z;\n            this.position.z += h;\n            if (faceDown) {\n                this.velocity = vectorMinus(this.velocity, 0.002);\n                this.momentum = vectorMinus(this.momentum, 0.002);\n                const vEnergy = Math.pow(this.velocity.length(), 2) / 2;\n                const lossEnergy = -Gravity.z * h;\n                const vscale = Math.sqrt(Math.max(1 - 2 * lossEnergy / Math.pow(this.velocity.length(), 2), 0));\n                if (vscale < 1)\n                    this.velocity = this.velocity.scale(vscale);\n                const wLossEnergy = lossEnergy - (vEnergy - Math.pow(this.velocity.length(), 2) / 2);\n                const mscale = Math.sqrt(Math.max(1 - 2 * wLossEnergy / Math.pow(this.momentum.length(), 2), 0));\n                if (mscale < 1)\n                    this.momentum = this.momentum.scale(mscale);\n            }\n            const vel = Vector3.add(this.velocity, Vector3.cross(this.momentum, rpos));\n            if (vel.z > 0)\n                return;\n            const rxy = Math.hypot(vel.x, vel.y) || 1;\n            const friction = 0.5;\n            const Fz = new Vector3(0, 0, -vel.z);\n            const Fxy = new Vector3(friction * vel.z * vel.x / rxy, friction * vel.z * vel.y / rxy, 0);\n            const v0 = vel;\n            const v1 = Vector3.add(Fz, Vector3.cross(Vector3.cross(rpos, Fz), rpos));\n            // velocity = v0 + v1 * t\n            // position = v0.z * t + v1.z * t * t / 2\n            const t = -1.5 * v0.z / v1.z;\n            if (isNaN(t) || t <= 0)\n                return;\n            const a = Vector3.add(this.velocity, Fz.scale(t));\n            const af = Fxy.scale(t);\n            const b = Vector3.add(this.momentum, Vector3.cross(rpos, Fz).scale(t));\n            const bf = Vector3.cross(rpos, Fxy).scale(t);\n            const _f = -(Vector3.dot(a, af) + Vector3.dot(b, bf)) / (Vector3.dot(af, af) + Vector3.dot(bf, bf));\n            const f = _f < 0 ? 0 : _f < 1 ? _f : 1;\n            const F = Vector3.add(Fz, Fxy.scale(f));\n            this.velocity = Vector3.add(this.velocity, F.scale(t));\n            this.momentum = Vector3.add(this.momentum, Vector3.cross(rpos, F).scale(t));\n        });\n    }\n    render(ctx) {\n        ctx.save();\n        this.position.y = 0;\n        Cube.coords.forEach(p => {\n            Cube.coords.forEach(q => {\n                if (Vector3.distance(p, q) != 2)\n                    return;\n                const [tp, tq] = [p, q].map(point => Vector3.add(this.position, this.rotation.transform(point).scale(this.size)));\n                const center = this.rotation.transform(Vector3.add(p, q).scale(0.5));\n                const ps = 1 / (1 + 0.1 * tp.y);\n                const qs = 1 / (1 + 0.1 * tq.y);\n                ctx.globalAlpha = 0.6 - 0.3 * center.y;\n                ctx.beginPath();\n                ctx.moveTo(tp.x * ps, -tp.z * ps);\n                ctx.lineTo(tq.x * qs, -tq.z * qs);\n                ctx.stroke();\n            });\n        });\n        ctx.restore();\n    }\n    static hitTest(cube1, cube2) {\n        for (const [a, b] of [[cube1, cube2], [cube2, cube1]]) {\n            const faces = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)].map(f => a.rotation.transform(f));\n            const coords = Cube.coords.map(c => Vector3.add(b.rotation.transform(c).scale(b.size), Vector3.sub(b.position, a.position)));\n            for (const f of faces) {\n                if (coords.every(c => a.size < Vector3.dot(f, c)) || coords.every(c => Vector3.dot(f, c) < -a.size))\n                    return false;\n            }\n        }\n        return true;\n    }\n    static hit(a, b) {\n        const diff = Vector3.sub(a.position, b.position);\n        if (this.hitTest(a, b)) {\n            const dir = diff.normalize();\n            const dot = Vector3.dot(Vector3.sub(a.velocity, b.velocity), dir);\n            if (dot < 0) {\n                a.velocity = Vector3.add(a.velocity, dir.scale(-dot));\n                b.velocity = Vector3.add(b.velocity, dir.scale(dot));\n                a.momentum = Vector3.add(a.momentum, randomDirection());\n                b.momentum = Vector3.add(b.momentum, randomDirection());\n            }\n        }\n    }\n}\nCube.coords = [...new Array(8)].map((_, i) => new Vector3(((i & 1) * 2 - 1), (((i >> 1) & 1) * 2 - 1), (((i >> 2) & 1) * 2 - 1)));\nCube.faces = [\n    new Vector3(-1, 0, 0), new Vector3(1, 0, 0),\n    new Vector3(0, -1, 0), new Vector3(0, 1, 0),\n    new Vector3(0, 0, -1), new Vector3(0, 0, 1)\n];\nfunction assignGlobal(data) {\n    for (const key in data) {\n        ;\n        window[key] = data[key];\n    }\n}\nassignGlobal({ Matrix3, Vector3, Cube });\nconst cube = new Cube(new Vector3(0, 0, 6));\nconst cube2 = new Cube(new Vector3(0, 0, 2));\nconst ctx = canvas.getContext('2d');\nsetInterval(() => {\n    Cube.hit(cube, cube2);\n    ctx.clearRect(0, 0, SIZE, SIZE);\n    [cube, cube2].forEach(c => {\n        c.update(0.1);\n        ctx.save();\n        ctx.translate(SIZE / 2, SIZE / 2);\n        ctx.lineWidth = 0.02;\n        ctx.scale(SIZE / 16, SIZE / 16);\n        c.render(ctx);\n        ctx.restore();\n    });\n}, 10);\nassignGlobal({ cube });\ndocument.onclick = () => {\n    cube.position = new Vector3(0, 0, 6);\n    cube.momentum = randomDirection(4);\n    cube2.position = new Vector3(0, 0, 2);\n    cube2.momentum = randomDirection(4);\n    cube.velocity = new Vector3(0, 0, 0);\n    cube2.velocity = new Vector3(0, 0, 0);\n};\n\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;